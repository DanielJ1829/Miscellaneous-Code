#PHYS10362
"""
Title: Introduction to Programming Second Assignment: Doppler Shifts
Username: x44401ap 
Student ID: 11312994
Date: 01/05/2024
Purpose of Code: The code determines a series of outputs and corresponding 
uncertainties by reading in a data file, plotting the result.

Using doppler shift principles and the curve_fit function we can determine the
velocity, angular velocity, the planet's mass and the distance between the planet
and the star it orbits. This is done by defining various functions then calling
them in the code below
"""
import numpy as np
import matplotlib.pyplot as plt
import scipy.constants as pc
from scipy.optimize import curve_fit
G = pc.gravitational_constant
lambda_0 = 656.281E-9
c = pc.speed_of_light
AU = pc.astronomical_unit


#This block creates and validates the data after reading it in
def generate_array():
    """
    Generates an initial array for the data from the two given functions.
    Includes errors of sevral different types, which are later eliminiated.
    ------------------------
    """
    data = []
    data1 = np.genfromtxt('doppler_data_1.csv', delimiter = ',', skip_header=0)
    data2 = np.genfromtxt('doppler_data_2.csv', delimiter = ',', skip_header=0)
    for line in data1:
        for i in line:
            try:
                float(i)
            except (ValueError, TypeError):
                np.delete(i)
            break
    np.append(line, data)
    for line in data2:
        for i in line:
            try:
                float(i)
            except TypeError:
                np.delete(i)
            break
    np.append(line, data)
    data = np.vstack((data1, data2))
    return data
def is_float(value):
    """
    Determines if a value is a float
    Parameters
    ----------
    value : the value being testes.

    Returns
    -------
    bool
        True of false of whether a point of data is a float.
    """
    try:
        if np.isnan(value):
            return False
        float(value)
        return True
    except (ValueError, TypeError):
        return False
def validation(initial_data):
    """
    Validates the data, removing all non numeric values
    Parameters
    ----------
    initial_data : the data generated by the previous function.

    Returns
    -------
    valid_data1 : an array of only numerical data.

    """
    valid_data1 = []
    for line in data0:
        try:
            if all(is_float(i) for i in line) and line[2]>0:
                valid_data1.append(line)
        except TypeError:
            pass
    valid_data1 = np.array(valid_data1)
    return valid_data1
def remove_outliers1(valid_data):
    """
    Removes large outliers using the interquartile range method
    Parameters
    ----------
    valid_data : an array of numerical data generated from previous functions.

    Returns
    -------
    valid_data : a new array without large outliers..

    """
    valid_data = []
    q75, q25= np.percentile(valid_data0[:, 1], [75, 25])
    iqr = q75 - q25
    for line in valid_data0:
        if line[1] < q75 +1.5*iqr and line[1] > q25 - 1.5*iqr:
            valid_data.append(line)
        else:
            pass
    valid_data = np.array(valid_data)
    return valid_data
def sort_data(valid_data):
    """
    Sorts the data into increasing order of time.
    Parameters
    ----------
    valid_data : the previous array; numeric data without large outliers.

    Returns
    -------
    sorted_data : an ordered array according to time.

    """
    sorted_indices = np.argsort(valid_data[:,0])
    sorted_data = valid_data[sorted_indices]
    return sorted_data


#This block creates 1D arrays from the validated data
def get_timespace(sorted_data):
    """
    Takes the time values for when the data was recorded and converts the
    values into seconds
    Parameters
    ----------
    sorted_data : The ordered time values.

    Returns
    -------
    t_seconds : time values in seconds.

    """
    t_years = sorted_data[:,0]
    t_np = np.array(t_years)
    t_seconds = (3600*24*365.25)*t_np
    return t_seconds
def recorded_wavelengths(sorted_data):
    """
    Outputs an array of wavelengths in metres from the sorted data
    Parameters
    ----------
    sorted_data : the ordered data.

    Returns
    -------
    lambda_metres : an array of wave lengths in metres.

    """
    lambda_recorded = sorted_data[:,1]
    lambda_metres = np.array(lambda_recorded)
    lambda_metres = (10**-9)*lambda_metres
    return lambda_metres
def wavelength_uncertainties():
    """
    Determines the uncertainties of the wavelengths in metres
    Returns
    -------
    uncertainties_metres : The uncertainties of the wavelengths in metres

    """
    uncertainties = np.array(sorted_data[:,2])
    uncertainties_metres = (1E-9)*uncertainties
    return uncertainties_metres


#This block creates functions and arrays needed to optimise and calculate
#the reduced chi squared value.
def model_function(t, v_0, omega, phi):
    """
    A code to get the general formula of the function we try to fit our data
    with
    Parameters
    ----------
    t : an array of time values in seconds.
    v_0 : the maximum velocity of the star in m/s.
    omega : the angular velocity in rad/s.
    phi : the phase shift in radians.

    Returns
    -------
    A model function to fit the data with.

    """
    return lambda_0*(1+(v_0/c)*np.sin(omega*t+phi))
def fitted_data(v_0, omega, t):
    """
    Determines an array of the model curve for each specific time value
    Parameters
    ----------
    v_0 : the maximum velocity of the star in m/s.
    omega : the angular velocity in rad/s.
    t : an array of time values in seconds.

    Returns
    -------
    An array of the model curve for each specific time value
    Parameters

    """
    return (lambda_0*(1+(v_0/c)*(np.sin(np.asarray(t)*omega+param[2]))))
def deviation(fitted, lambda_metres):
    """
    A function that generates an array of deviations between the recorded data
    and the fitted curve
    Parameters
    ----------
    fitted : The array from the values on the curve.
    lambda_metres : The recorded data

    Returns
    -------
    deviation : The square root of the variance between the points, treating
    the curve as the average/mean value for each data point.
    """
    var = (1/len(fitted))*np.sum((fitted-lambda_metres)**2)
    deviation = np.sqrt(var)
    return deviation
def correct_data(lambda_metres, fitted, uncertainties, model, time):
    """
    Corrects the data using the fact that most data that's over 3 sigma out 
    can be eliminated.
    Parameters
    ----------
    lambda_metres : The recorded data in metres.
    fitted : the data from the curve that fits the data.
    uncertainties : the uncertainties of the wavelengths in metres.
    model : the formua for a curve that fits the data.

    Returns
    -------
    corrected_data : the new data with removed outliers.
    fitted_new : the new curve without data points where outliers were removed.
    corrected_uncertainties : new uncertainties removing those where the
    outliers were.
    new_model : a better formula to fit the data, using new parameter values.
    t_new : the new time array with the outlier times removed.

    """
    corrected_data=[]
    fitted_new = []
    corrected_uncertainties = []
    t_new = []
    new_model = []
    difference = np.array(fitted - lambda_metres)
    for i in range(len(lambda_metres)):
        if np.absolute(difference[i]) < 3*deviation:
            corrected_data.append(lambda_metres[i])
            fitted_new.append(fitted[i])
            corrected_uncertainties.append(uncertainties[i])
            t_new.append(time[i])
            new_model.append(model[i])
        else:
            pass
    t_new = np.array(t_new)
    return corrected_data, fitted_new, corrected_uncertainties, new_model, t_new


#This block is additional, allowing the user to estimate values for the
#parameters
def v0_guess():
    """
    Allows the user to make a guess on v_0
    Returns
    -------
    v_0 : either the standard guess or the users guess in m/s.
    """
    while True:
        try:
            ans = str(input("Would you like to guess v_0? (Enter Yes/No) "))
            ans = ans.lower()
            if ans == 'yes':
                while True:
                    try:
                        v_0 = float(input("Enter your guess for v_0: "))
                        return v_0
                    except ValueError:
                        print("Error: Please enter a numerical value for v_0.")
                break
            elif ans == 'no':
                v_0 = 50
                break
        except TypeError:
            print("Error: Please enter Yes or No. (Note this isn't caps"
                  "sensitive)")
    return v_0
def omega_guess():
    """
    Allows the user to guess omega
    Returns
    -------
    omega : Either 3x10^-8 rad/s or the users guess so long as it's within a 
    given range.
    """
    while True:
        try:
            ans = str(input("Would you like to guess omega? (Enter Yes/No) "))
            ans = ans.lower()
            if ans == 'yes':
                while True:
                    try:
                        omega = float(input("Enter your guess for omega (Note: "
                                          "omega takes small values of the"
                                          "order 10^-8; please guess between"
                                          " 0 and 10^-7 radians: "))
                        if omega <= 0 or omega >= 1E-7:
                            print("Error: The value entered is out of the required range."
                                  " Please enter a value between 0 and 10^-7. ")
                        else:
                            return omega
                    except ValueError:
                        print("Error: Please enter a numerical value for omega.")
                break
            elif ans == 'no':
                omega = 3E-8
                break
        except TypeError:
            print("Error: Please enter Yes or No. (Note this isn't caps"
                  "sensitive)")
    return omega
def phi_guess():
    """
    Allows the user to make a guess on phi to prove it does not need to be 
    known in order for the code to fit the curve correctly.

    Returns
    -------
    phi : either pi radians or the user's guess.
    """
    print("We can determine the fit without knowing phi. Please enter a guess"
          " between 0 and 2 pi if you'd like to convince yourself of this.")
    while True:
        try:
            ans = str(input("Would you like to guess phi? (Enter Yes/No) "))
            ans = ans.lower()
            if ans == 'yes':
                while True:
                    try:
                        phi = float(input("Enter your guess for phi: "))
                        if phi >= 2*np.pi or phi < 0:
                            print("Error: The value entered is out of the required range."
                              " Please enter a value between 0 and 2 pi. ")
                        else:
                            return phi
                    except ValueError:
                        print("Error: Please enter a numerical value for phi.")
                break
            elif ans == 'no':
                phi = 50
                break
        except TypeError:
            print("Error: Please enter Yes or No. (Note this isn't caps"
                  "sensitive)")
    return phi
def line_of_sight_angle():
    """
    Generalises the data for line of sight angles
    Returns
    -------
    theta : The line of sight angle in radians of the orbiting plane of the
    system and the observer's line of sight.
    """
    print("In practice, bodies will not orbit in a plane parallel to the"
          " observer's line of sight. Would you like to add a line of sight"
          " angle, theta, where theta is the angle between the normal of the"
          " orbiting plane and the line of sight?")
    while True:
        try:
            ans = str(input("(Enter Yes/No) "))
            ans = ans.lower()
            if ans == 'yes':
                while True:
                    try:
                        theta = float(input("Enter your guess for this angle in"
                                           " degrees (between 0 and 90): "))
                        if theta > 90 or phi < 0:
                            print("Error: The value entered is out of the required range."
                              " Please enter a value between 0 and 2 pi. ")
                        else:
                            return theta
                    except ValueError:
                        print("Error: Please enter a numerical value for phi.")
                break
            elif ans == 'no':
                theta = 90
                break
        except ValueError:
            print("Error: Please enter Yes or No. (Note this isn't caps"
                  "sensitive)")
    theta = np.radians(theta)
    return theta


#this block of code outputs the values required for the assignment and converts
#units into appropriate quantities for the calculations to be made correctly.
def get_reduced_chi_sq(corrected_data, fitted):
    """
    A function that computes the reduced-chi squared value from the data

    Parameters
    ----------
    corrected_data : An array of the data without the outliers.
    fitted : The curve used to fit the data with the optimised parameters.

    Returns
    -------
    reduced_chi_squared : The reduced-chi squared value (dimensionless).
    """
    chi_squared = np.sum(((corrected_data-fitted)/corrected_uncertainties)**2)
    reduced_chi_squared = chi_squared/(len(corrected_data)-3)
    return reduced_chi_squared
def sm_to_kg(param):
    """
    Converts the solar mass to kilograms
    The solar mass is solar mass is (1.98847±0.00007)×10**30 kg. Take note of 
    the uncertainty for later functions
    Parameters
    ----------
    param : outputted data from the curve fitting.

    Returns
    -------
    solar_mass : The solar mass in kilograms.
    """
    solar_mass = (param[1]**2)*(AU)**3/(G)
    solar_mass = 1.98847E+30
    return solar_mass
def jovian_in_kg():
    """
    Computes the jovian mass in kilograms
    jupiter mass is 1.89813+/-0.00019 x 10**27 kg
    Returns
    -------
    jovian_mass : the jovian mass in kilograms
    """
    jovian_mass = 1.89813E+27
    return jovian_mass
def obtain_r(param, solar_mass):
    """
    determines the distance between the two bodies
    Parameters
    ----------
    param : an array containing the optimised velocity and angular velocity
    using the curve fit function.
    solar_mass : the solar mass in kilograms.
    Returns
    -------
    r_AU : the distance between the bodies in astronomical units.
    """
    r_cubed = pc.gravitational_constant*2.78*solar_mass/(param[1])**2
    r = np.cbrt(r_cubed)
    r_AU = r/AU
    return r_AU
def obtain_m_p(r_AU, param):
    """
    Obtains the planet's mass in jovian masses
    Parameters
    ----------
    r_AU : the distance between the bodies in astronomical units.
    param : an array containing the optimised velocity and angular velocity

    Returns
    -------
    m_p_jovian : the planet's mass in jovian masses
    """
    m_p_in_kg = param[0]*np.sqrt((r_AU*AU*SOLAR_MASS*2.78)/G)
    m_p_jovian = m_p_in_kg/JOVIAN_MASS
    return m_p_jovian
def obtain_uncertainties():
    '''
    obtains the uncertainties of m_p and r by combining errors
    in quadrature - see comments of above masses as these display the numbers
    used for numerical uncertainty calculation below.
    
    Returns
    -------
    uncertainty_m_p, uncertainty_r
    '''
    uncertainty_r = r*np.sqrt((0.00007/1.98847)**2+(np.sqrt(param_cov[1,1])/param[1])**2)
    uncertainty_m_p = JOVIAN_MASS*np.sqrt((param_cov[0,0]/(param[0])**2)+(uncertainty_r/r)**2+(0.00007/1.98847)**2+(0.00019/1.89813)**2)
    return uncertainty_m_p, uncertainty_r


#this code plots the data and allows users to choose their plot style
def plot_and_save_errorbars(param, reduced_chi_squared):
    """
    A function that plots and saves a graph of the fit against the data with
    error bars on each data point

    Parameters
    ----------
    param : an array containing the optimised velocity and angular velocity
    reduced_chi_squared : the reduced chi squared value of the fitted curve.

    Returns
    -------
    A plot.
    """
    ax = fig.add_subplot()
    ax.errorbar(t_new, corrected_data, yerr=corrected_uncertainties,
                color = 'red', fmt='o', capsize=0)
    ax.plot(t_new, corrected_data, 'o', color ='red',
                    label ='data w/error bars')
    ax.plot(t_new, fitted, '-', color ='blue',
                    label ='fitted line')
    ax.set_ylabel('wavelength')
    ax.text(1.64e8,6.5628e-7+0.925e-12, s = 'v_0: {0:.3f}'.format(param[0]),
            fontsize ='small')
    ax.text(1.47e8,6.5628e-7+0.915e-12, s = 'omega: {0:.3E}'.format(param[1]),
            fontsize ='small')
    ax.text(1.22e8,6.5628e-7+0.905e-12,
            s = 'reduced-chi squared: {0:.3f}'.format(reduced_chi_squared),
            fontsize ='small')
    ax.set_xlabel('time')
    fig.savefig('fitted_curve_with_data.png')
    plt.legend()
    plt.show()
def plot_and_save(param, reduced_chi_squared):
    """
    A function that plots and saves a graph of the fit against the data

    Parameters
    ----------
    param : an array containing the optimised velocity and angular velocity
    reduced_chi_squared : the reduced chi squared value of the fitted curve.

    """
    ax = fig.add_subplot()
    ax.plot(t_new, corrected_data, 'o', color ='red', label ="data")
    ax.plot(t_new, fitted, '-', color ='blue',
                    label ='fitted line')
    ax.set_ylabel('wavelength')
    ax.text(1.64e8,6.5628e-7+0.935e-12, s = 'v_0: {0:.3f}'.format(param[0]),
            fontsize ='small')
    ax.text(1.47e8,6.5628e-7+0.925e-12, s = 'omega: {0:.3E}'.format(param[1]),
            fontsize ='small')
    ax.text(1.22e8,6.5628e-7+0.915e-12,
            s = 'reduced-chi squared: {0:.3f}'.format(reduced_chi_squared),
            fontsize ='small')
    ax.set_xlabel('time')
    fig.savefig('fitted_curve_with_data.png')
    plt.legend()
    plt.show()

def choose_plot_style():
    """
    A function that lets the user choose the style of plotting
    """
    while True:
        try:
            ans = str(input("Would you like to plot the fit with"
                                  " error bars? (Enter Yes/No): "))
            ans = ans.lower()
            if ans == 'yes':
                plot_and_save_errorbars(param, reduced_chi_squared)
                break
            elif ans == 'no':
                plot_and_save(param, reduced_chi_squared)
                break
        except TypeError:
            print("Error: Please enter Yes or No.")

data0 = generate_array()
valid_data0 = validation(data0)
valid_data = remove_outliers1(valid_data0)
sorted_data=sort_data(valid_data)
time = get_timespace(sorted_data)
lambda_metres = recorded_wavelengths(sorted_data)
v_0, omega, phi = v0_guess(), omega_guess(), phi_guess()
theta = line_of_sight_angle()
model = model_function(time, 50, 3E-8, phi)
uncertainties = wavelength_uncertainties()
fig = plt.figure()
param, param_cov = curve_fit(model_function, time, lambda_metres,
                             p0=(v_0, omega, phi), sigma=uncertainties,
                             absolute_sigma=True)
v_0, omega = param[0], param[1]
fitted = fitted_data(v_0, omega, time)
deviation = deviation(fitted, lambda_metres)
corrected_data, fitted_new, corrected_uncertainties, new_model, t_new = correct_data(lambda_metres,
                                                                  fitted,
                                                                uncertainties,
                                                                model,
                                                                time)
param, param_cov = curve_fit(model_function, t_new, corrected_data,
                             p0=(50, 3E-8, np.pi), sigma=corrected_uncertainties,
                             absolute_sigma=True)
fitted = (lambda_0*(1+(param[0]/c)*(np.sin(np.asarray(t_new)*param[1]+param[2]))))
reduced_chi_squared= get_reduced_chi_sq(corrected_data, fitted)
SOLAR_MASS = sm_to_kg(param)
r = obtain_r(param, SOLAR_MASS)
JOVIAN_MASS = jovian_in_kg()
m_p = obtain_m_p(r, param)
uncert_m_p, uncert_r = obtain_uncertainties()
choose_plot_style()
print('the reduced-chi squared value is {0:.3f}'.format(reduced_chi_squared))
print('v_0 = {0:.4g}'.format(param[0]/np.sin(theta)),'+/-',
      '{0:.4g}'.format(np.sqrt(param_cov[0,0])), 'm/s,')
print('omega = {0:4.3E}'.format(param[1]),'+/-',
      '{0:4.3E}'.format(np.sqrt(param_cov[1,1])), 'rad/s')
print("the planet's mass is {0:.4g}".format(m_p),"+/-",
      '{0:.4g}'.format(uncert_m_p), "jovian masses")
print('The separation of the bodies is {0:.4g}'.format(r),
      '+/- {0:.4g}'.format(uncert_r), 'AU')